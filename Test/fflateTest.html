<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8" />
<title>æ¨¡æ“¬ Twitch ä¸Šå‚³é©—è­‰ â€” GZIP + Base91 æ¸¬è©¦</title>
<script src="./fflate.js"></script>
<style>
  body { background:#0b0b0b; color:#eee; font-family:"Microsoft JhengHei",sans-serif; padding:20px; }
  textarea { width:100%; height:220px; font-family:monospace; background:#111; color:#eee; border:1px solid #333; padding:8px; }
  button { margin:8px 0; padding:8px 14px; font-size:14px; }
  .box { background:#111; padding:12px; border-radius:8px; border:1px solid #333; margin:10px 0; white-space:pre-wrap; word-break:break-all; }
</style>
</head>
<body>
  <h1>æ¨¡æ“¬ Twitch Configuration ä¸Šå‚³ï¼ˆGZIP + Base91ï¼‰</h1>
  <p>è²¼å…¥ JSON â†’ Key Minify â†’ GZIP å£“ç¸® â†’ Base91 ç·¨ç¢¼ â†’ æª¢æŸ¥æ˜¯å¦é€šé 5KB é™åˆ¶ä¸¦å¯é‚„åŸã€‚</p>

  <textarea id="jsonInput" placeholder="è«‹è²¼ä¸Š JSONâ€¦">
{
  "name": "æ¸¬è©¦åˆé›†",
  "roles": [
    {"name": "æ‘æ°‘", "ability": "æŠ•ç¥¨", "team": "å–„"},
    {"name": "ç‹¼äºº", "ability": "æ®ºäºº", "team": "æƒ¡"}
  ],
  "meta": {"author":"Joe", "date":"2025-10-26"}
}
  </textarea>
  <br>
  <button id="runBtn">ğŸ”§ å£“ç¸®ä¸¦æ¨¡æ“¬ä¸Šå‚³</button>

  <h3>çµæœ</h3>
  <div id="output" class="box">å°šæœªåŸ·è¡Œ</div>

<script>
// ------- Base91 (ç´”å­—ä¸²å®‰å…¨) -------
const base91Table =
  "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789" +
  "!#$%&()*+,./:;<=>?@[]^_`{|}~\"";
const base91Dict = Object.fromEntries([...base91Table].map((c, i) => [c, i]));
function base91Encode(bytes) {
  let b = 0, n = 0, out = "";
  for (let i = 0; i < bytes.length; i++) {
    b |= bytes[i] << n; n += 8;
    if (n > 13) {
      let v = b & 8191;
      if (v > 88) { b >>= 13; n -= 13; }
      else { v = b & 16383; b >>= 14; n -= 14; }
      out += base91Table[v % 91] + base91Table[Math.floor(v / 91)];
    }
  }
  if (n) out += base91Table[b % 91] + (n > 7 || b > 90 ? base91Table[Math.floor(b / 91)] : "");
  return out;
}
function base91Decode(str) {
  let b = 0, n = 0, out = [], v = -1;
  for (let i = 0; i < str.length; i++) {
    const code = base91Dict[str[i]];
    if (code === undefined) continue;
    if (v < 0) v = code;
    else {
      v += code * 91;
      b |= v << n; n += (v & 8191) > 88 ? 13 : 14;
      do { out.push(b & 255); b >>= 8; n -= 8; } while (n > 7);
      v = -1;
    }
  }
  if (v + 1) out.push((b | (v << n)) & 255);
  return new Uint8Array(out);
}

// ------- Key Minifyï¼ˆå¯é€†ï¼‰ -------
function minifyAndShortenKeys(obj) {
  const keyMap = new Map(); let idx = 0;
  const shortKey = k => keyMap.has(k) ? keyMap.get(k) : (keyMap.set(k, `k${idx++}`), keyMap.get(k));
  const walk = x => Array.isArray(x) ? x.map(walk)
    : (x && typeof x === "object") ? Object.fromEntries(Object.entries(x).map(([k,v]) => [shortKey(k), walk(v)]))
    : x;
  return { json: JSON.stringify(walk(obj)), keyMap };
}
function restoreKeys(obj, keyMap) {
  const rev = new Map([...keyMap.entries()].map(([k,v]) => [v,k]));
  const walk = x => Array.isArray(x) ? x.map(walk)
    : (x && typeof x === "object") ? Object.fromEntries(Object.entries(x).map(([k,v]) => [rev.get(k) || k, walk(v)]))
    : x;
  return walk(obj);
}

// ------- æ¨¡æ“¬ Twitch æª¢æŸ¥ï¼ˆUTF-8 é•·åº¦ / æ§åˆ¶å­—å…ƒ / 5KBï¼‰ -------
function simulateTwitchChecks(str) {
  const enc = new TextEncoder(); const bytes = enc.encode(str);
  const segLimit = 5000;
  // ç¦æ­¢ 0-31 æ§åˆ¶å­—å…ƒï¼ˆå…è¨± 9,10,13ï¼‰
  const bad = [];
  for (let i=0;i<bytes.length;i++){
    const c = bytes[i];
    if (c >= 0 && c <= 31 && c !== 9 && c !== 10 && c !== 13) bad.push({i,c});
  }
  return { lengthBytes: bytes.length, within: bytes.length <= segLimit, bad, segLimit };
}

// ------- å£“ç¸®ï¼ˆGZIPï¼‰+ ç·¨ç¢¼ï¼ˆBase91ï¼‰ -------
function gzipToBase91(str) {
  const { gzipSync, strToU8 } = fflate;
  const gz = gzipSync(strToU8(str));          // Uint8Array
  const enc = base91Encode(gz);               // å­—ä¸²ï¼ˆæ¯” Base64 æ›´å°ï¼‰
  return { gzBytes: gz, encoded: enc };
}
function ungzipFromBase91(s) {
  const { gunzipSync, strFromU8 } = fflate;
  const u8 = base91Decode(s);
  return strFromU8(gunzipSync(u8));
}

// ------- ä¸»æµç¨‹ -------
document.getElementById("runBtn").addEventListener("click", () => {
  const raw = document.getElementById("jsonInput").value.trim();
  const out = document.getElementById("output");
  if (!raw) { out.textContent = "âš ï¸ è«‹å…ˆè¼¸å…¥ JSON"; return; }
  try {
    const obj = JSON.parse(raw);                            // é©—è­‰åˆæ³• JSON
    const { json: minified, keyMap } = minifyAndShortenKeys(obj);

    const t0 = performance.now();
    const { gzBytes, encoded } = gzipToBase91(minified);    // GZIP â†’ Base91
    const t1 = performance.now();

    const chk = simulateTwitchChecks(encoded);              // æ¨¡æ“¬ä¸Šå‚³æª¢æŸ¥
    const restoredMin = ungzipFromBase91(encoded);          // è§£å› minify ç‰ˆæœ¬
    const restoredObj = restoreKeys(JSON.parse(restoredMin), keyMap);
    const ok = JSON.stringify(restoredObj) === JSON.stringify(obj);

    const enc = new TextEncoder();
    const origBytes = enc.encode(raw).length;
    const miniBytes = enc.encode(minified).length;
    const gzLen    = gzBytes.length;        // äºŒé€²ä½å£“ç¸®é•·åº¦
    const b91Len   = encoded.length;        // è¦ä¸Šå‚³çš„å­—ä¸²é•·åº¦ï¼ˆASCII 1å­—å…ƒ=1byteï¼‰

    out.textContent =
`åŸå§‹å¤§å°ï¼š${origBytes} bytes
minify å¾Œï¼š${miniBytes} bytes
GZIP äºŒé€²ä½å¤§å°ï¼š${gzLen} bytes
Base91 å­—ä¸²é•·åº¦ï¼ˆä¸Šå‚³é•·åº¦ï¼‰ï¼š${b91Len} bytes

Twitch æ¨¡æ“¬æª¢æŸ¥ï¼ˆä¸Šé™ ${chk.segLimit} bytesï¼‰ï¼š
  â€¢ æ˜¯å¦åœ¨é™åˆ¶å…§ï¼š${chk.within ? "âœ… æ˜¯" : "âŒ å¦"}
  â€¢ æ§åˆ¶å­—å…ƒæ•¸ï¼š${chk.bad.length}

é‚„åŸé©—è­‰ï¼š${ok ? "âœ… æ­£ç¢ºé‚„åŸ" : "âŒ é‚„åŸå¤±æ•—"}
è€—æ™‚ï¼šç´„ ${(t1 - t0).toFixed(2)} ms`;
  } catch (e) {
    out.textContent = "éŒ¯èª¤ï¼šè¼¸å…¥ä¸æ˜¯åˆæ³• JSON æˆ–è™•ç†å¤±æ•—ã€‚\n" + e.message;
  }
});
</script>
</body>
</html>
